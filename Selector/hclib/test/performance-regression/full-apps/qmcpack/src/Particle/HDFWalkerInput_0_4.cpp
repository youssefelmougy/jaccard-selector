//////////////////////////////////////////////////////////////////
// (c) Copyright 2005- by Jeongnim Kim
//////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////
//   Jeongnim Kim
//   National Center for Supercomputing Applications &
//   Materials Computation Center
//   University of Illinois, Urbana-Champaign
//   Urbana, IL 61801
//   e-mail: jnkim@ncsa.uiuc.edu
//
// Supported by
//   National Center for Supercomputing Applications, UIUC
//   Materials Computation Center, UIUC
//////////////////////////////////////////////////////////////////
// -*- C++ -*-
#include <Particle/MCWalkerConfiguration.h>
#include <Particle/HDFWalkerInput_0_4.h>
#include <io/hdf_archive.h>
#include <mpi/mpi_datatype.h>
#include <mpi/collectives.h>
#ifdef HAVE_ADIOS
#include "ADIOS/ADIOS_config.h"
#endif

namespace qmcplusplus
{

HDFWalkerInput_0_4::HDFWalkerInput_0_4(MCWalkerConfiguration& W, Communicate* c, const HDFVersion& v)
  : targetW(W), myComm(c), cur_version(0,4)
{
  i_info.version=v;
}

HDFWalkerInput_0_4::~HDFWalkerInput_0_4()
{
  //if(h_plist != H5P_DEFAULT) H5Pclose(h_plist);
}

void HDFWalkerInput_0_4::checkOptions(xmlNodePtr cur)
{
  i_info.reset();
  string froot,cfile;
  string collected("no");
  OhmmsAttributeSet pAttrib;
  pAttrib.add(i_info.nprocs,"nprocs");
  pAttrib.add(i_info.rank,"node");
  pAttrib.add(cfile,"href");
  pAttrib.add(cfile,"file");
  pAttrib.add(froot,"fileroot");
  pAttrib.add(collected,"collected");
  pAttrib.put(cur);
  if(froot.empty())
    return;
  int ext;
#ifdef HAVE_ADIOS
  if(ADIOS::getRdADIOS())
  {
    ext=froot.find(".config.bp");
  }
  else if(ADIOS::getRdHDF5())
#endif
  {
    ext=froot.find(hdf::config_ext);
  }
  if(ext<froot.size())
  {
    //remove extenstion
    froot.erase(froot.begin()+ext,froot.end());
  }
  //file generated by a serial run is automatically collected
  i_info.collected = ((collected == "yes") || (i_info.nprocs == 1));
  if(i_info.collected)
    FileStack.push(froot);
  else
  {
    if(i_info.nprocs>1)//need to process multiple files
    {
      int nprocs_now=myComm->size();
      if(i_info.nprocs>nprocs_now)//using less nodes
      {
        int np=i_info.nprocs/nprocs_now;
        int pid=myComm->rank(), ip=0;
        while(pid<i_info.nprocs && ip<np)
        {
          char *h5name=new char[froot.size()+10];
          sprintf(h5name,"%s.p%03d",froot.c_str(),pid++);
          FileStack.push(h5name);
          delete [] h5name;
          pid += nprocs_now;
        }
      }
      else
      {
        int pid=myComm->rank()%i_info.nprocs;
        char *h5name=new char[froot.size()+10];
        sprintf(h5name,"%s.p%03d",froot.c_str(),pid);
        FileStack.push(h5name);
        delete [] h5name;
      }
    }
    else
    {
      FileStack.push(froot);
    }
  }
}

bool HDFWalkerInput_0_4::put(xmlNodePtr cur)
{
  checkOptions(cur);
  if(FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << endl;
    return false;
  }
#ifdef HAVE_ADIOS
  return read_adios(cur);
#else
  bool success = true;
  while(FileStack.size())
  {
    FileName=FileStack.top();
    FileStack.pop();
    string h5name(FileName);
    //success |= read_hdf5_scatter(h5name);
    success |= read_hdf5(h5name);
  }
  return success;
#endif
}

bool HDFWalkerInput_0_4::read_hdf5(string h5name)
{

  int nw_in=0;

  h5name.append(hdf::config_ext);
  hdf_archive hin(myComm,false); //everone reads this
  bool success=hin.open(h5name,H5F_ACC_RDONLY);
  //check if hdf and xml versions can work together
  HDFVersion aversion;

  hin.read(aversion,hdf::version);
  if(!(aversion < i_info.version))
  {
    int found_group=hin.is_group(hdf::main_state);
    hin.push(hdf::main_state);
    hin.read(nw_in,hdf::num_walkers);
  }
  else
  {
    app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << endl;
  }

  if(nw_in==0)
  {
    app_error() << " No walkers in " << h5name << endl;
    return false;
  }

  typedef vector<QMCTraits::RealType>  Buffer_t;
  Buffer_t posin;
  TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
  posin.resize(dims[0]*dims[1]*dims[2]);

  hyperslab_proxy<Buffer_t,3> slab(posin,dims);
  hin.read(slab,hdf::walkers);

  vector<int> woffsets;
  hin.read(woffsets,"walker_partition");

  int np1=myComm->size()+1;
  vector<int> counts(np1);
  if(woffsets.size()!= np1)
  {
    woffsets.resize(myComm->size()+1,0);
    FairDivideLow(nw_in,myComm->size(),woffsets);
  }

  app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << endl;
  nw_in=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];
  {
    int nitems=targetW.getTotalNum()*OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    targetW.createWalkers(nw_in);
    Buffer_t::iterator it(posin.begin()+woffsets[myComm->rank()]*nitems);
    for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
    {
      std::copy(it,it+nitems,get_first_address(targetW[iw]->R));
      it += nitems;
    }
  }

  //{
  //  char fname[128];
  //  sprintf(fname,"%s.p%03d.xyz",FileName.c_str(),myComm->rank());
  //  ofstream fout(fname);
  //  MCWalkerConfiguration::iterator it = targetW.begin();
  //  int iw=0;
  //  while(it != targetW.end())
  //  {
  //    fout << iw << endl;
  //    MCWalkerConfiguration::Walker_t& thisWalker(**it);
  //    for(int iat=0; iat<targetW.getTotalNum(); ++iat)
  //      fout << thisWalker.R[iat] << endl;
  //    ++it; ++iw;
  //  }
  //}
  return true;
}

bool HDFWalkerInput_0_4::read_hdf5_scatter(string h5name)
{

  int nw_in=0;
  h5name.append(hdf::config_ext);

  if(myComm->rank()==0)
  {
    hdf_archive hin(myComm); //everone reads this
    bool success=hin.open(h5name,H5F_ACC_RDONLY);
    //check if hdf and xml versions can work together
    HDFVersion aversion;

    hin.read(aversion,hdf::version);
    if(!(aversion < i_info.version))
    {
      int found_group=hin.is_group(hdf::main_state);
      hin.push(hdf::main_state);
      hin.read(nw_in,hdf::num_walkers);
    }
    else
    {
      app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << endl;
    }
  }

  myComm->barrier();
  mpi::bcast(*myComm,nw_in);

  if(nw_in==0)
  {
    app_error() << " No walkers in " << h5name << endl;
    return false;
  }

  typedef vector<QMCTraits::RealType>  Buffer_t;

  int np1=myComm->size()+1;
  vector<int> counts(myComm->size()),woffsets(np1,0);
  FairDivideLow(nw_in,myComm->size(),woffsets);

  int nw_loc=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];

  int nitems=targetW.getTotalNum()*OHMMS_DIM;
  for(int i=0; i<woffsets.size(); ++i) woffsets[i]*=nitems;
  for(int i=0; i<counts.size(); ++i) counts[i]=woffsets[i+1]-woffsets[i];

  TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
  Buffer_t posin(nw_in*nitems),posout(counts[myComm->rank()]);

  if(myComm->rank()==0)
  {
    hdf_archive hin(myComm); 
    bool success=hin.open(h5name,H5F_ACC_RDONLY);
    hyperslab_proxy<Buffer_t,3> slab(posin,dims);
    hin.push(hdf::main_state);
    hin.read(slab,hdf::walkers);
  }

  mpi::scatterv(*myComm,posin,posout,counts,woffsets);

  int curWalker=targetW.getActiveWalkers();
  targetW.createWalkers(nw_loc);
  Buffer_t::iterator it(posout.begin());
  for(int i=0,iw=curWalker; i<nw_loc;++i,++iw)
  {
    std::copy(it,it+nitems,get_first_address(targetW[iw]->R));
    it += nitems;
  }
  return true;
}

bool HDFWalkerInput_0_4::read_phdf5(string h5name)
{
//Broken
//#if defined(H5_HAVE_PARALLEL) && defined(ENABLE_PHDF5)
//  hin.read(aversion,hdf::version);
//  int found_group=hin.is_group(hdf::main_state);
//  if(!found_group)
//    continue;
//  //start main_state
//  hin.push(hdf::main_state);
//  int nw_in=0;
//  hin.read(nw_in,hdf::num_walkers);
//  vector<int> woffsets(myComm->size()+1,0);
//  FairDivideLow(nw_in,myComm->size(),woffsets);
//  int mynode=myComm->rank();
//  int nw_loc=woffsets[mynode+1]-woffsets[mynode];
//  cout << "node =" << mynode << " nw_loc=" << nw_loc << " nw_in=" << nw_in << endl;
//  //TinyVector<hsize_t,3> gcounts, counts, offset;
//  hsize_t gcounts[3], counts[3], offset[3];
//  gcounts[0]=nw_in;
//  gcounts[1]=targetW.getTotalNum();
//  gcounts[2]=OHMMS_DIM;
//  counts[0]=nw_loc;
//  counts[1]=targetW.getTotalNum();
//  counts[2]=OHMMS_DIM;
//  offset[0]=woffsets[mynode];
//  offset[1]=0;
//  offset[2]=0;
//  int nitems=targetW.getTotalNum()*OHMMS_DIM;
//  typedef vector<QMCTraits::RealType>  Buffer_t;
//  Buffer_t posin(nw_loc*nitems);
//  hid_t dataset = H5Dopen(hin.top(),hdf::walkers);
//  hid_t dataspace = H5Dget_space(dataset);
//  int rank_n = H5Sget_simple_extent_ndims(dataspace);
//  int status_n = H5Sget_simple_extent_dims(dataspace, gcounts, NULL);
//  hid_t type_id=get_h5_datatype(posin[0]);
//  hid_t memspace = H5Screate_simple(3, counts, NULL);
//  herr_t status = H5Sselect_hyperslab(dataspace,H5S_SELECT_SET, offset,NULL,counts,NULL);
//  status = H5Dread(dataset, type_id, memspace, dataspace, hin.xfer_plist, &posin[0]);
//  H5Sclose(dataspace);
//  H5Sclose(memspace);
//  H5Dclose(dataset);
//  int curWalker = targetW.getActiveWalkers();
//  targetW.createWalkers(nw_loc);
//  Buffer_t::iterator it(posin.begin());
//  for(int i=0,iw=curWalker; i<nw_loc; ++i,++iw)
//  {
//    std::copy(it,it+nitems,get_first_address(targetW[iw]->R));
//    it += nitems;
//  }
//#endif
  return true;
}
bool HDFWalkerInput_0_4::read_adios(xmlNodePtr cur)
{
  //this is too messy. cleanup or use read_hdf5 
#ifdef HAVE_ADIOS
  checkOptions(cur);
  if(FileStack.empty())
  {
    app_error() << "  No valid input hdf5 is found." << endl;
    return false;
  }
  //use collective I/O  for parallel runs with a file
  //i_info.parallel = ((myComm->size()>1) && i_info.collected);
  while(FileStack.size())
  {
    FileName=FileStack.top();
    FileStack.pop();
    string h5name(FileName);
    int success = 0;
    hdf_archive hin(myComm,true);
    if(ADIOS::getRdADIOS())
    {
      h5name.append(".config.bp");
      success=ADIOS::open(h5name, myComm->getMPI());
    }
    else if(ADIOS::getRdHDF5())
    { 
      h5name.append(hdf::config_ext);
      success=hin.open(h5name,H5F_ACC_RDONLY);
    }
    mpi::bcast(*myComm,success);
    if(!success)
    {
      app_error() << "  HDFWalkerInput_0_4::put Cannot open " << h5name << endl;
      continue;
    }
    //check if hdf and xml versions can work together
    HDFVersion aversion;
    typedef vector<QMCTraits::RealType>  Buffer_t;
    Buffer_t posin;
    if(ADIOS::getRdHDF5())
    {
      hin.read(aversion,hdf::version);
      mpi::bcast(*myComm,aversion.version);
      if(aversion < i_info.version)
      {
        app_error() << " Mismatched version. xml = " << i_info.version << " hdf = " << aversion << endl;
        continue;
      }
      int found_group=hin.is_group(hdf::main_state);
      mpi::bcast(*myComm,found_group);
      if(!found_group)
        continue;
      hin.push(hdf::main_state);
    }
    int nw_in=0;
    if(ADIOS::getRdADIOS())
    {
      int * data;
      int index;
      ADIOS::read_scalar(data, "walker_num", index);
      for(int i=0; i<index; i++)
      {
        nw_in += data[i];
      }
      free(data);
    }
    else if(ADIOS::getRdHDF5())
    {
      hin.read(nw_in,hdf::num_walkers);
      mpi::bcast(*myComm,nw_in);
    }
    if(nw_in==0)
    {
      app_error() << "  HDFWalkerInput_0_4::put empty walkers " << endl;
      continue;
    }
    TinyVector<size_t,3> dims(nw_in,targetW.getTotalNum(),OHMMS_DIM);
    if(!myComm->rank())
    {
      posin.resize(dims[0]*dims[1]*dims[2]);
      if(ADIOS::getRdADIOS())
      {
        ADIOS::read_walkers(posin, "walkers");
      } 
      else if(ADIOS::getRdHDF5())
      {
        hyperslab_proxy<Buffer_t,3> slab(posin,dims);
        hin.read(slab,hdf::walkers);
      }
    }
    if(ADIOS::getRdADIOS())
    {
      ADIOS::close();
    }
    app_log() << " HDFWalkerInput_0_4::put getting " << dims[0] << " walkers " << posin.size() << endl;
    int nitems=targetW.getTotalNum()*OHMMS_DIM;
    int curWalker = targetW.getActiveWalkers();
    if(myComm->size()==1)
    {
      targetW.createWalkers(nw_in);
      Buffer_t::iterator it(posin.begin());
      for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
      {
        std::copy(it,it+nitems,get_first_address(targetW[iw]->R));
        it += nitems;
      }
    }
    else
    {
      vector<int> counts(myComm->size()),woffsets(myComm->size()+1,0);
      FairDivideLow(nw_in,myComm->size(),woffsets);
      //reset the number of walkers
      nw_in=woffsets[myComm->rank()+1]-woffsets[myComm->rank()];
      for(int i=0; i<woffsets.size(); ++i)
        woffsets[i]*=nitems;
      for(int i=0; i<counts.size(); ++i)
        counts[i]=woffsets[i+1]-woffsets[i];
      Buffer_t posout(nw_in*nitems);
      mpi::scatterv(*myComm,posin,posout,counts,woffsets);
      targetW.createWalkers(nw_in);
      Buffer_t::iterator it(posout.begin());
      for(int i=0,iw=curWalker; i<nw_in; ++i,++iw)
      {
        std::copy(it,it+nitems,get_first_address(targetW[iw]->R));
        it += nitems;
      }
    }
  }
#endif
  return true;
}

}
/***************************************************************************
 * $RCSfile$   $Author: jnkim $
 * $Revision: 2303 $   $Date: 2007-11-19 13:25:50 -0600 (Mon, 19 Nov 2007) $
 * $Id: HDFWalkerInput_0_4.cpp 2303 2007-11-19 19:25:50Z jnkim $
 ***************************************************************************/
