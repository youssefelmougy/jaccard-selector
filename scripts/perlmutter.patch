diff --git a/src/bale_classic/convey/twohop.c b/src/bale_classic/convey/twohop.c
index b45b25d..741d1e3 100644
--- a/src/bale_classic/convey/twohop.c
+++ b/src/bale_classic/convey/twohop.c
@@ -297,7 +297,7 @@ column_advance(twohop_t* twohop)
     else
       shmemx_team_alltoallv(twohop->col_recv_bufs, twohop->col_offsets, twohop->recv_sizes,
                             twohop->col_send_bufs, twohop->col_offsets, twohop->send_sizes,
-                            twohop->col_team, twohop->col_sync[twohop->col_flip]);
+                            twohop->col_team);//, twohop->col_sync[twohop->col_flip]);
     twohop->col_flip ^= 1;
 #else
     int error = MPI_Alltoall(twohop->send_sizes, 1, MPI_INT,
diff --git a/src/bale_classic/spmat/spmat.h b/src/bale_classic/spmat/spmat.h
index 4511c61..1227c7d 100644
--- a/src/bale_classic/spmat/spmat.h
+++ b/src/bale_classic/spmat/spmat.h
@@ -214,7 +214,8 @@ sparsemat_t *       erdos_renyi_random_graph(int64_t n, double p, edge_type edge
 sparsemat_t *       gen_star_graph(int64_t m, int mode);
 sparsemat_t *       generate_kronecker_graph_from_spec(int mode, int * spec, int num);
 sparsemat_t *       geometric_random_graph(int64_t n, double r, edge_type edgetype, self_loops loops, uint64_t seed, SHARED point_t ** out_points);
-
+sparsemat_t *	    generate_dense_tril_matrix(int64_t n_dense, int64_t values_dense);
+sparsemat_t *       generate_kmer_matrix(int64_t num_rows_kmer, int64_t num_cols_kmer, double nonzero_prob_kmer);
 
 edge_list_t *       init_edge_list(int64_t nalloc, int weighted);
 sparsemat_t *       init_matrix(int64_t numrows, int64_t numcols, int64_t nnz_this_thread, int weighted);
diff --git a/src/bale_classic/spmat/spmat_io.upc b/src/bale_classic/spmat/spmat_io.upc
index d71ae59..8341b87 100644
--- a/src/bale_classic/spmat/spmat_io.upc
+++ b/src/bale_classic/spmat/spmat_io.upc
@@ -598,8 +598,10 @@ sparsemat_t * read_matrix_mm_to_dist(char * name) {
     }else{
       tri = calloc(nnz, sizeof(w_edge_t));    
       while(fscanf(fp,"%"PRId64" %"PRId64" %"PRId64"\n", &row, &col, &val) != EOF){
-        tri[pos].row = row - 1;
-        tri[pos].col = col - 1;
+	row--;
+	col--;
+        tri[pos].row = row;
+        tri[pos].col = col;
         tri[pos++].val = val;
         nnz_per_th[row % THREADS]++;
         rowcount[row]++;
diff --git a/src/bale_classic/spmat/spmat_utils.upc b/src/bale_classic/spmat/spmat_utils.upc
index e90c9b5..fc7e663 100644
--- a/src/bale_classic/spmat/spmat_utils.upc
+++ b/src/bale_classic/spmat/spmat_utils.upc
@@ -1690,3 +1690,402 @@ void clear_d_array(d_array_t * A)
 }
 
 
+/*! \brief Create an nxn dense lower triangular matrix (without diagonal values) on one PE and create a distributed matrix
+  from that.
+  * Only PE 0 creates the matrix and distributes it to all PEs.
+  * 
+  * \param n_dense The number of rows/columns.
+  * \param values_dense 0: no value per nonzero, 1: value per nonzero (values initialized to 0).
+  * \return The sparsemat_t struct.
+  * \ingroup spmatgrp
+  */
+sparsemat_t * generate_dense_tril_matrix(int64_t n_dense, int64_t values_dense) {
+  typedef struct pkg_rowcol_t{
+    int64_t row;    
+    int64_t col;
+  }pkg_rowcol_t;
+
+  int64_t nr, nc, nnz = 0, i, pe;
+  SHARED int64_t * sh_data;
+  sh_data = lgp_all_alloc (THREADS*4, sizeof(int64_t));
+
+  int64_t * rowcount;
+  edge_t * edges;
+  w_edge_t * tri;
+  if(!MYTHREAD){
+    int64_t * nnz_per_th = calloc(THREADS, sizeof(int64_t));
+
+    // Initialize (nr, nc, nnz)
+    nr = n_dense;
+    nc = n_dense;
+    nnz = n_dense*(n_dense-1)/2;
+
+    // Allocate space to store the matrix data    
+    rowcount = calloc(nr, sizeof(int64_t));
+    
+    // Generate the data
+    int64_t row, col, val, pos = 0;
+    if(values_dense == 0){
+      edges = calloc(nnz, sizeof(edge_t));
+      for (int i_dense = 2; i_dense < n_dense+1; i_dense++) {
+        for (int j_dense = 1; j_dense < i_dense; j_dense++) {
+            row = i_dense;
+            col = j_dense;
+            row--;
+            col--;
+            edges[pos].row   = row;
+            edges[pos++].col = col;
+            nnz_per_th[row % THREADS]++;
+            rowcount[row]++;
+        }
+      }
+      qsort( edges, nnz, sizeof(edge_t), edge_comp);
+    }else{
+      tri = calloc(nnz, sizeof(w_edge_t));    
+      for (int i_dense = 2; i_dense < n_dense+1; i_dense++) {
+        for (int j_dense = 1; j_dense < i_dense; j_dense++) {
+            row = i_dense;
+            col = j_dense;
+            row--;
+            col--;
+            tri[pos].row = row;
+            tri[pos].col = col;
+            tri[pos++].val = val;
+            nnz_per_th[row % THREADS]++;
+            rowcount[row]++;
+        }
+      }
+      qsort( tri, nnz, sizeof(w_edge_t), w_edge_comp);
+    }
+    
+    for(i = 0; i < THREADS; i++){
+      lgp_put_int64(sh_data, i, nnz_per_th[i]);
+      lgp_put_int64(sh_data, i+THREADS, nr);
+      lgp_put_int64(sh_data, i+2*THREADS, nc);
+      lgp_put_int64(sh_data, i+3*THREADS, values_dense);
+    }
+    free(nnz_per_th);
+  }
+  
+  lgp_barrier();
+
+  int64_t * lsh_data = lgp_local_part(int64_t, sh_data);
+  if(lsh_data[0] == -1)
+    return(NULL);
+  
+  int64_t lnnz = lsh_data[0];
+  nr = lsh_data[1];
+  nc = lsh_data[2];
+  int value = (lsh_data[3] != 0L);
+  
+  sparsemat_t * A = init_matrix(nr, nc, lnnz, value);
+  SHARED int64_t * tmp_offset = lgp_all_alloc(nr + THREADS, sizeof(int64_t));
+
+  /* set up offset array and tmp_offset */
+  lgp_barrier();
+  lgp_all_free(sh_data);
+  
+  if(!MYTHREAD){
+    for(i = 0; i < nr; i++)
+      lgp_put_int64(tmp_offset, i, rowcount[i]);
+    free(rowcount);
+  }
+
+  lgp_barrier();
+
+  int64_t * ltmp_offset = lgp_local_part(int64_t, tmp_offset);
+  A->loffset[0] = 0;
+  for(i = 1; i <= A->lnumrows; i++){
+    A->loffset[i] = A->loffset[i-1] + ltmp_offset[i-1];
+    ltmp_offset[i-1] = 0;
+  }
+
+  int64_t fromth;
+  w_edge_t pkg;
+  exstack_t * ex = exstack_init(256, sizeof(w_edge_t));
+  if( ex == NULL ) return(NULL);
+  
+  /* distribute the matrix to all other PEs */
+  /* pass around the nonzeros */
+  /* this is a strange exstack loop since only PE0 has data to push */
+  i = 0;
+  while(exstack_proceed(ex, (i == nnz))){
+    while(i < nnz){
+      if(value == 0){
+        pkg.row = edges[i].row;
+        pkg.col = edges[i].col;
+      }else{
+        pkg.row = tri[i].row;
+        pkg.col = tri[i].col;
+        pkg.val = tri[i].val;
+      }
+      pe = pkg.row % THREADS;
+      if(!exstack_push(ex, &pkg, pe))
+        break;
+      i++;
+    }
+    exstack_exchange(ex);
+
+    while(exstack_pop(ex, &pkg, &fromth)){
+      int64_t row = pkg.row/THREADS;
+      int64_t pos = A->loffset[row] + ltmp_offset[row];
+      A->lnonzero[pos] = pkg.col;
+      if(value) A->lvalue[pos] = pkg.val;
+      ltmp_offset[row]++;
+    }
+  }
+
+  lgp_barrier();
+  if(!MYTHREAD){
+    if(value == 0)
+      free(edges);
+    else
+      free(tri);
+  }
+
+  //if(!MYTHREAD){
+  //  printf("Generated and distributed an %dx%d dense lower triangular matrix", n_dense, n_dense);
+  //}
+
+  lgp_all_free(tmp_offset);
+  exstack_clear(ex);
+  sort_nonzeros(A);
+  return(A);
+}
+
+/*! \brief Creating custom random number generator (from C++ to C)
+  */
+// Custom Mersenne Twister constants and parameters
+#define MT19937_N       624
+#define MT19937_M       397
+#define MT19937_MATRIX  0x9908b0dfU
+#define MT19937_UPPER   0x80000000U
+#define MT19937_LOWER   0x7fffffffU
+
+// Mersenne Twister state and current index
+static uint32_t mt[MT19937_N];
+static int mti = MT19937_N + 1;
+
+// Initialize the Mersenne Twister with a seed
+void mt19937_initialize(uint32_t seed) {
+    mt[0] = seed;
+    for (mti = 1; mti < MT19937_N; ++mti) {
+        mt[mti] = (1812433253U * (mt[mti - 1] ^ (mt[mti - 1] >> 30)) + mti);
+    }
+}
+
+// Generate a random 32-bit unsigned integer
+uint32_t mt19937_random() {
+    if (mti >= MT19937_N) {
+        // Generate MT19937_N words at once
+        int k;
+        for (k = 0; k < MT19937_N - MT19937_M; ++k) {
+            uint32_t y = (mt[k] & MT19937_UPPER) | (mt[k + 1] & MT19937_LOWER);
+            mt[k] = mt[k + MT19937_M] ^ (y >> 1) ^ (y & 1 ? MT19937_MATRIX : 0U);
+        }
+        for (; k < MT19937_N - 1; ++k) {
+            uint32_t y = (mt[k] & MT19937_UPPER) | (mt[k + 1] & MT19937_LOWER);
+            mt[k] = mt[k + MT19937_M - MT19937_N] ^ (y >> 1) ^ (y & 1 ? MT19937_MATRIX : 0U);
+        }
+        uint32_t y = (mt[MT19937_N - 1] & MT19937_UPPER) | (mt[0] & MT19937_LOWER);
+        mt[MT19937_N - 1] = mt[MT19937_M - 1] ^ (y >> 1) ^ (y & 1 ? MT19937_MATRIX : 0U);
+        mti = 0;
+    }
+
+    // Temper the generated value
+    uint32_t y = mt[mti++];
+    y ^= (y >> 11);
+    y ^= (y << 7) & 0x9d2c5680U;
+    y ^= (y << 15) & 0xefc60000U;
+    y ^= (y >> 18);
+    return y;
+}
+
+// Generate a random double in the range [0, 1)
+double mt19937_random_double() {
+    return (double)mt19937_random() / ((uint32_t)-1);
+}
+
+/*! \brief Create an mxn sparse kmer matrix for Jaccard computations on one PE and create a distributed matrixfrom that.
+   (guarantees atleast one nonzero per row and column, analogous with the presence of each kmer in atleast one data sample) 
+  * Only PE 0 creates the matrix and distributes it to all PEs.
+  *
+  * \param num_rows_kmer The number of rows.
+  * \param num_cols_kmer The number of columns.
+  * \param nonzero_prob_kmer The probability of the presence of a nonzero.
+  * \return The sparsemat_t struct.
+  * \ingroup spmatgrp
+  */
+sparsemat_t * generate_kmer_matrix(int64_t num_rows_kmer, int64_t num_cols_kmer, double nonzero_prob_kmer) {
+  typedef struct pkg_rowcol_t{
+    int64_t row;
+    int64_t col;
+  }pkg_rowcol_t;
+
+  int64_t nr, nc, nnz = 0, i, pe;
+  SHARED int64_t * sh_data;
+  sh_data = lgp_all_alloc (THREADS*4, sizeof(int64_t));
+
+  int64_t * rowcount;
+  edge_t * edges;
+  w_edge_t * tri;
+  if(!MYTHREAD){
+    int64_t * nnz_per_th = calloc(THREADS, sizeof(int64_t));
+
+    // Set the seed for the random number generator
+    mt19937_initialize(1);
+
+    // Initialize a list to store the non-zero entries as (row, col) pairs
+    int max_entries = num_rows_kmer * num_cols_kmer;
+    int* nonzero_rows = (int*)malloc(max_entries * sizeof(int));
+    int* nonzero_cols = (int*)malloc(max_entries * sizeof(int));
+    int num_nonzero_entries = 0;
+
+    // Generate kmer matrix with the  given nonzero probability
+    for (int i_kmer = 0; i_kmer < num_rows_kmer; ++i_kmer) {
+        for (int j_kmer = 0; j_kmer < num_cols_kmer; ++j_kmer) {
+            double random_value = mt19937_random_double();
+            if (random_value < nonzero_prob_kmer) {
+                nonzero_rows[num_nonzero_entries] = i_kmer + 1; // Add 1 to row index (1-based)
+                nonzero_cols[num_nonzero_entries] = j_kmer + 1; // Add 1 to column index (1-based)
+                num_nonzero_entries++;
+            }
+        }
+    }
+
+    // Ensure at least one nonzero entry per column and per row
+    for (int i_kmer = 0; i_kmer < num_cols_kmer; ++i_kmer) {
+        int has_nonzero_entry = 0;
+        for (int jj = 0; jj < num_nonzero_entries; ++jj) {
+            if (nonzero_cols[jj] == i_kmer + 1) { // Check column index (1-based)
+                has_nonzero_entry = 1;
+                break;
+            }
+        }
+        if (!has_nonzero_entry) {
+            // If the column is all zeros, set a random row index to 1
+            int random_row = mt19937_random() % num_rows_kmer + 1; // Add 1 to row index (1-based)
+            nonzero_rows[num_nonzero_entries] = random_row;
+            nonzero_cols[num_nonzero_entries] = i_kmer + 1; // Add 1 to column index (1-based)
+            num_nonzero_entries++;
+        }
+    }
+
+    // Initialize (nr, nc, nnz)
+    nr = num_rows_kmer;
+    nc = num_cols_kmer;
+    nnz = num_nonzero_entries;
+
+    // Allocate space to store the matrix data
+    rowcount = calloc(nr, sizeof(int64_t));
+
+    // Push the data into spmat structures
+    int64_t row, col, val, pos = 0;
+    edges = calloc(nnz, sizeof(edge_t));
+    for (int ii = 0; ii < num_nonzero_entries; ++ii) {
+      row = nonzero_rows[ii];
+      col = nonzero_cols[ii];
+      row--;
+      col--;
+      edges[pos].row   = row;
+      edges[pos++].col = col;
+      nnz_per_th[row % THREADS]++;
+      rowcount[row]++;
+    }
+    qsort( edges, nnz, sizeof(edge_t), edge_comp);
+
+    for(i = 0; i < THREADS; i++){
+      lgp_put_int64(sh_data, i, nnz_per_th[i]);
+      lgp_put_int64(sh_data, i+THREADS, nr);
+      lgp_put_int64(sh_data, i+2*THREADS, nc);
+      lgp_put_int64(sh_data, i+3*THREADS, 0); //values
+    }
+    free(nnz_per_th);
+  }
+
+  lgp_barrier();
+
+  int64_t * lsh_data = lgp_local_part(int64_t, sh_data);
+  if(lsh_data[0] == -1)
+    return(NULL);
+
+  int64_t lnnz = lsh_data[0];
+  nr = lsh_data[1];
+  nc = lsh_data[2];
+  int value = (lsh_data[3] != 0L);
+
+  sparsemat_t * A = init_matrix(nr, nc, lnnz, value);
+  SHARED int64_t * tmp_offset = lgp_all_alloc(nr + THREADS, sizeof(int64_t));
+
+  /* set up offset array and tmp_offset */
+  lgp_barrier();
+  lgp_all_free(sh_data);
+
+  if(!MYTHREAD){
+    for(i = 0; i < nr; i++)
+      lgp_put_int64(tmp_offset, i, rowcount[i]);
+    free(rowcount);
+  }
+
+  lgp_barrier();
+
+  int64_t * ltmp_offset = lgp_local_part(int64_t, tmp_offset);
+  A->loffset[0] = 0;
+  for(i = 1; i <= A->lnumrows; i++){
+    A->loffset[i] = A->loffset[i-1] + ltmp_offset[i-1];
+    ltmp_offset[i-1] = 0;
+  }
+
+  int64_t fromth;
+  w_edge_t pkg;
+  exstack_t * ex = exstack_init(256, sizeof(w_edge_t));
+  if( ex == NULL ) return(NULL);
+
+  /* distribute the matrix to all other PEs */
+  /* pass around the nonzeros */
+  /* this is a strange exstack loop since only PE0 has data to push */
+  i = 0;
+  while(exstack_proceed(ex, (i == nnz))){
+    while(i < nnz){
+      if(value == 0){
+        pkg.row = edges[i].row;
+        pkg.col = edges[i].col;
+      }else{
+        pkg.row = tri[i].row;
+        pkg.col = tri[i].col;
+        pkg.val = tri[i].val;
+      }
+      pe = pkg.row % THREADS;
+      if(!exstack_push(ex, &pkg, pe))
+        break;
+      i++;
+    }
+    exstack_exchange(ex);
+
+    while(exstack_pop(ex, &pkg, &fromth)){
+      int64_t row = pkg.row/THREADS;
+      int64_t pos = A->loffset[row] + ltmp_offset[row];
+      A->lnonzero[pos] = pkg.col;
+      if(value) A->lvalue[pos] = pkg.val;
+      ltmp_offset[row]++;
+    }
+  }
+
+  lgp_barrier();
+  if(!MYTHREAD){
+    if(value == 0)
+      free(edges);
+    else
+      free(tri);
+  }
+
+  //if(!MYTHREAD){
+  //  printf("Generated and distributed k-mer matrix with %d rows, %d columns, and %lg probability.\n", num_rows_kmer, num_cols_kmer, nonzero_prob_kmer);
+  //}
+
+  lgp_all_free(tmp_offset);
+  exstack_clear(ex);
+  sort_nonzeros(A);
+  return(A);
+}
+
